---///Thread Life Circle, состояние объекта Thread///---

New – нить до вызова метода старт
Running – нить после вызова метода start()
Ready – нить запущена, но ждёт своей очереди
Time waiting – состояние нити при вызове метода sleep(), это значит, что нить ждет ограниченное время
Waiting – состояние при вызове методов join()  у другой нити. Либо если вызван метод wait().
Blocked – состояние при котором нить вошла в блок кода synchronized, который занят. Нить будет заблокирована и будет ждать освобождение объекта-мьютекса.

Terminated – когда нить заканчивает работу и не находится в состоянии new или running


---///Все нюансы создания и запуска новой нити, демоны///---
Работа обычной программы, состоящей из одной нити, завершается вместе с работой главной нити. После этого Java-машина освобождает память программы.
Когда мы запускаем дочернюю нить, программа продолжает работать, даже если главная нить завершилась. Java-машина не закрывает программу, пока есть хотя бы одна работающая нить.
Java позволяет запустить нить в «режиме демона» (daemon). Работа такой нити ничем не отличается от других, но если в программе все обычные нити завершили работу, но остались только нити-демоны —
Java-машина завершит программу.
Нить в режиме демона – это служебная нить, которая не нужна отдельно от программы.



---///Все нюансы прерывания/остановки нитей///---
В Java, если кто-то хочет остановить работающую нить, у него есть возможность подать нити об этом сигнал. Для этого нужно установить скрытую переменную нити isInterrupted в true.
И когда нить вызывает методы Thread.sleep() или метод join(), в этих методах происходит скрытая проверка – а не выставлен ли у нашей текущей нити флаг isInterrupted. Если этот флаг
выставлен (переменная isInterrupted равно true), то методы выбрасывают исключение InterruptedException.



---///Имя нити и приоритет///---
Если мы не задаём имя нити и её приоритет, то они устанавливаются по умолчанию.
Имя устанавливается типа Thread-0, приоритет по умолчанию устанавливается как 5.
Мы можем самостоятельно установить имя треда, передав его в конструкторе, либо написать код типа: thread.setName(«Name Thread»). Приоритет нити мы можем установить самостоятельно,
написав код типа: thread.setPriority(9);
Приоритеты могут задаваться в виде константных значений: Thread.MIN_PRIORITY, Thread.NORMAL_PRIORITY, Thread.MAX_PRIORITY.



---///Методы Thread///---
sleep() – принимает в параметры милесекунды. Заставляет поток спать, переданное кол-во милесекунд. Метод выбрасывает исключение: InterruptedException.
join() – заставляет один поток, ожидать другой. И только потом продолжает работу.
В примере ниже первым запускается поток thread, на след строчке мы вызываем у данного потока join(), это значит, что все остальные потоки ждут, пока thread завершит работу,
и только потом начинают выполнение. Это позволяет нам синхронизировать работу потоков. Метод выбрасывает исключение: InterruptedException.
Метод join() может принимать в качестве параметра милисекунды. Это означает, что потоки ожидают тот поток, на котором вызван join() n милесекунд, а потом продолжают свою работу.



---///Concurency/Parallelism///---
Concurency (согласованность) – означает выполнение сразу нескольких задач, но не обязательно в одно и то же время. В зависимости от процессора компьютера concurrency может достигаться разными способами.
Parallelism – означает выполнение 2-х и более задач в одно и то же время, т.е. параллельно. В компьютерах с многоядерным процесором concurrency может достигаться за счет parallilism.
Concurrent (параллельный)
1 пример.
Нам даются два задания:
1)петь и кушать (пример Concurency ) – мы не можем одновременно и петь и кушать, но мы можем делать это поочередно.
2)готовить и говорить по телефону (пример Concurency) – мы можем одновременно и готовить и говорить по телефону. Одновременное выполнение двух процессов – это пример concurrent.
В обоих случаях задания выполняются одновременно.
Таким образом concurency и concurent – это не одно и то же. Concurency может быть как и concurent, так и не concurent.



---///Asynchronous/Synchronous///---
Пример.
Нам нужно написать два письма: одно другу, второе маме. Мы не пишем два письма одновременно, мы пишем сначала одно письмо, потом второе. Это называется синхронное программирование.
Важно не путать данный процесс с синхронным плаванием, когда несколько человек выполняют одно и то же действие одновременно.

Пример 2. Мы готовим бутерброд и нам нужно постирать бельё. Эти процессы происходят одновременно. Такой процесс называется ассинхронное программирование.
Это достигается при помощи concurrency. Если процессор одноядерный, то поток переключается между процессами, но на многоядерном процессоре, мы можем добиться параллельного выполнения
В синхронном программировании задачи выполняются последовательно друг за другом.
В асинхронном программировании каждая следующая задача не ждет окончания выполнения предыдущей.
Асинхронное программирование помогает достичь concurrency.


---///Ключевое слово volatile(изменчивый)///---
Когда мы помечаем переменную ключевым словом volatile, это означает, что значение данной переменной не будет сохраняться в кеш память какого-либо потока,
а будет храниться в общей памяти. Ключевое слово volatile гарантирует нам, что все потоки будут использовать одно и то же значение переменной.
Для синхронизации значения переменной между потоками ключевое слово volatile используется тогда, когда только один поток может изменять значение этой переменной, а остальные потоки могут его только читать.
Когда несколько потоков меняют значение одной переменной, мы используем synchronized методы.

---///Data race и synchronized методы///---
Data race(гонка данных) – когда несколько потоков меняют значение одной переменной и их поведение не синхронизировано.
 Доп. Пояснение: это проблема, которая может возникнуть, когда два и более потоков обращаются к одной и той же переменной и как минимум 1 поток её изменяет.
Чтобы справиться с data race, используется ключевое слово synchronized. В примере ниже, при объявлении метода мы используем synchronized, это означает,
что использовать данный метод в один момент времени может только один поток.


